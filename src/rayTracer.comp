#version 460 core

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D viewport;
uniform vec3 cameraPosition;
uniform vec3 cameraDirection;
uniform int cameraFov;

bool rayIntersectsCube(vec3 rayOrigin, vec3 rayDirection, vec3 cubePosition, float cubeSize, out vec3 hitFaceNormal) {
	vec3 minBound = cubePosition - vec3(cubeSize * 0.5);
    vec3 maxBound = cubePosition + vec3(cubeSize * 0.5);

    vec3 tMin = (minBound - rayOrigin) / rayDirection;
    vec3 tMax = (maxBound - rayOrigin) / rayDirection;

    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);

    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    if (tNear <= 0.0 || tNear >= tFar)
		return false;
		
	vec3 hitPoint = rayOrigin + tNear * rayDirection;

	if (abs(hitPoint.x - minBound.x) < 0.001)
		hitFaceNormal = vec3(-1.0, 0.0, 0.0);
	else if (abs(hitPoint.x - maxBound.x) < 0.001)
		hitFaceNormal = vec3(1.0, 0.0, 0.0);
	else if (abs(hitPoint.y - minBound.y) < 0.001)
		hitFaceNormal = vec3(0.0, -1.0, 0.0);
	else if (abs(hitPoint.y - maxBound.y) < 0.001)
		hitFaceNormal = vec3(0.0, 1.0, 0.0);
	else if (abs(hitPoint.z - minBound.z) < 0.001)
		hitFaceNormal = vec3(0.0, 0.0, -1.0);
	else if (abs(hitPoint.z - maxBound.z) < 0.001)
		hitFaceNormal = vec3(0.0, 0.0, 1.0);

	return true;
}

void main() {
    vec4 color = vec4(0, 0, 0, 1.0);
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

	ivec2 viewportSize = imageSize(viewport);
	float aspectRatio = float(viewportSize.x) / float(viewportSize.y);

	vec3 worldUp = vec3(0, 1, 0);

	vec3 nCameraDirection = normalize(cameraDirection);
	vec3 cameraRight = cross(nCameraDirection, worldUp);
	vec3 cameraUp = cross(cameraRight, nCameraDirection);

	float fov = radians(cameraFov);
	float nearPlaneDist = tan(fov / 2) * 2;

	vec3 nearPlaneCenter = cameraPosition + (nCameraDirection * nearPlaneDist);
	vec3 rayOrigin = nearPlaneCenter
		+ cameraRight * (-(float(pixelCoord.x * 2 - viewportSize.x) / viewportSize.x)) * aspectRatio
		- cameraUp * -(float(pixelCoord.y * 2 - viewportSize.y) / viewportSize.y);
	vec3 rayDirection = normalize(rayOrigin - cameraPosition);

	float cubeSize = 1;
	vec3 voxel1 = vec3(0, 0, 12);
	vec3 voxel2 = vec3(-0.5, -3, 8);
	vec3 voxel3 = vec3(-2, -1, 4);

	vec3 hitFaceNormal;
	bool intersects;

	// z sorting would be necessary
	if (intersects = rayIntersectsCube(rayOrigin, rayDirection, voxel3, cubeSize, hitFaceNormal))
		color = vec4(1, 0, 0, 1);
	else if (intersects = rayIntersectsCube(rayOrigin, rayDirection, voxel2, cubeSize, hitFaceNormal))
		color = vec4(0, 1, 0, 1);
	else if (intersects = rayIntersectsCube(rayOrigin, rayDirection, voxel1, cubeSize, hitFaceNormal))
		color = vec4(0, 0, 1, 1);

	if (intersects) {
		vec4 lightColor = vec4(vec3(1), 1); // r g b intensity
		vec3 invLightDirection = normalize(vec3(0.5, 1.5, 1));
		float specularIntensity = 0.3;
		float specularExponent = 5;

		float dotln = dot(invLightDirection, hitFaceNormal);
		if (dotln <= 0)
			color = vec4(vec3(0), 1);
		else {
			// diffusion
			color.rgb = (color * lightColor * dotln).rgb * lightColor.a;

			// specular
			vec3 lightReflectionDirection = reflect(invLightDirection * -1, hitFaceNormal);
			float i = dot(lightReflectionDirection, rayDirection * -1);
			if (i > 0)
				color.rgb += specularIntensity * pow(i, specularExponent) * lightColor.rgb;
		}
	}

	imageStore(viewport, pixelCoord, color);
}