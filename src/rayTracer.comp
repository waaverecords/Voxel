#version 460 core

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D viewport;
layout(std430, binding = 0) buffer DataBuffer {
	bool voxels[];
};

uniform vec3 cameraPosition;
uniform vec3 cameraDirection;
uniform float cameraFov;

bool rayIntersectsCube(vec3 rayOrigin, vec3 rayDirection, vec3 cubePosition, float voxelSize, out vec3 hitPoint, out vec3 hitFaceNormal) {
	vec3 minBound = cubePosition - vec3(voxelSize * 0.5);
    vec3 maxBound = cubePosition + vec3(voxelSize * 0.5);

    vec3 tMin = (minBound - rayOrigin) / rayDirection;
    vec3 tMax = (maxBound - rayOrigin) / rayDirection;

    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);

    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    if (tNear <= 0.0 || tNear >= tFar)
		return false;
		
	hitPoint = rayOrigin + tNear * rayDirection;

	if (abs(hitPoint.x - minBound.x) < 0.001)
		hitFaceNormal = vec3(-1.0, 0.0, 0.0);
	else if (abs(hitPoint.x - maxBound.x) < 0.001)
		hitFaceNormal = vec3(1.0, 0.0, 0.0);
	else if (abs(hitPoint.y - minBound.y) < 0.001)
		hitFaceNormal = vec3(0.0, -1.0, 0.0);
	else if (abs(hitPoint.y - maxBound.y) < 0.001)
		hitFaceNormal = vec3(0.0, 1.0, 0.0);
	else if (abs(hitPoint.z - minBound.z) < 0.001)
		hitFaceNormal = vec3(0.0, 0.0, -1.0);
	else if (abs(hitPoint.z - maxBound.z) < 0.001)
		hitFaceNormal = vec3(0.0, 0.0, 1.0);

	return true;
}

vec3 mortonToVec3(uint morton) {
	// TODO: optimise this, either go with full it shifting, or go with precomputed tables
    uint x = 0u;
    uint y = 0u;
    uint z = 0u;
    uint shift = 0u;

    for (uint i = 0u; i < 10u; i++) { // 10 bits per dimension
        x |= ((morton >> (2u * i)) & 1u) << i;
        y |= ((morton >> (2u * i + 1u)) & 1u) << i;
        z |= ((morton >> (2u * i + 2u)) & 1u) << i;
    }

    return vec3(float(x), float(y), float(z));
}

void main() {
    vec4 color = vec4(0, 0, 0, 1.0);
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

	ivec2 viewportSize = imageSize(viewport);
	float aspectRatio = float(viewportSize.x) / float(viewportSize.y);

	vec3 worldUp = vec3(0, 1, 0);

	vec3 nCameraDirection = normalize(cameraDirection);
	vec3 cameraRight = normalize(cross(nCameraDirection, worldUp));
	vec3 cameraUp = normalize(cross(cameraRight, nCameraDirection));

	float fov = radians(cameraFov);
	float nearPlaneDist = tan(fov / 2) * 2;

	vec3 nearPlaneCenter = cameraPosition + (nCameraDirection * nearPlaneDist);
	vec3 rayOrigin = nearPlaneCenter
		+ cameraRight * (float(pixelCoord.x * 2 - viewportSize.x) / viewportSize.x) * aspectRatio
		- cameraUp * -(float(pixelCoord.y * 2 - viewportSize.y) / viewportSize.y);
	vec3 rayDirection = normalize(rayOrigin - cameraPosition);

	float voxelSize = 1;

	bool hit = false;
	vec3 hitFaceNormal;
	vec3 hitPoint;
	vec3 closestHitFaceNormal;
	float closestHitDistance = 1.0 / 0.0;

	for (uint i = 0; i < 1024; i++) {

		if (!voxels[i])
			continue;

		uint x = (i >> 2) & 1;
		uint y = (i >> 1) & 1;
		uint z = i & 1;

		vec3 voxelPosition = mortonToVec3(i);

		if (rayIntersectsCube(rayOrigin, rayDirection, voxelPosition, voxelSize, hitPoint, hitFaceNormal)) {
			hit = true;
			float hitDistance = length(hitPoint - rayOrigin);
			if (hitDistance < closestHitDistance) {
				closestHitDistance = hitDistance;
				closestHitFaceNormal = hitFaceNormal;
			}
		}
	}

	if (hit) {
		color = vec4(1, 0, 0, 1);

		// lighting
		// https://math.hws.edu/graphicsbook/c7/s2.html

		vec4 lightColor = vec4(vec3(1), 1); // r g b intensity
		vec3 invLightDirection = normalize(vec3(-1, 1.5, 0.4));
		float specularIntensity = 0.3;
		float specularExponent = 5;

		float dotln = dot(invLightDirection, closestHitFaceNormal);
		if (dotln <= 0)
			color = vec4(vec3(0), 1);
		else {
			// diffusion
			color.rgb = (color * lightColor * dotln).rgb * lightColor.a;

			// specular
			vec3 lightReflectionDirection = reflect(invLightDirection * -1, closestHitFaceNormal);
			float i = dot(lightReflectionDirection, rayDirection * -1);
			if (i > 0)
				color.rgb += specularIntensity * pow(i, specularExponent) * lightColor.rgb;
		}
	}

	imageStore(viewport, pixelCoord, color);
}