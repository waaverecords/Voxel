#version 460 core

#extension GL_NV_gpu_shader5 : enable

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D viewport;
layout(std430, binding = 0) buffer DataBuffer {
	bool voxels[];
};
layout(std430, binding = 1) buffer VoxelDataStorage {
	uint64_t header;
	uint8_t voxelData[];
};

uniform vec3 cameraPosition;
uniform vec3 cameraDirection;
uniform float cameraFov;

bool rayIntersectsCube(vec3 rayOrigin, vec3 rayDirection, vec3 cubePosition, float voxelSize, out vec3 hitPoint, out vec3 hitFaceNormal) {
	vec3 minBound = cubePosition - vec3(voxelSize * 0.5);
    vec3 maxBound = cubePosition + vec3(voxelSize * 0.5);

    vec3 tMin = (minBound - rayOrigin) / rayDirection;
    vec3 tMax = (maxBound - rayOrigin) / rayDirection;

    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);

    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    if (tNear <= 0.0 || tNear >= tFar)
		return false;
		
	hitPoint = rayOrigin + tNear * rayDirection;

	if (abs(hitPoint.x - minBound.x) < 0.001)
		hitFaceNormal = vec3(-1.0, 0.0, 0.0);
	else if (abs(hitPoint.x - maxBound.x) < 0.001)
		hitFaceNormal = vec3(1.0, 0.0, 0.0);
	else if (abs(hitPoint.y - minBound.y) < 0.001)
		hitFaceNormal = vec3(0.0, -1.0, 0.0);
	else if (abs(hitPoint.y - maxBound.y) < 0.001)
		hitFaceNormal = vec3(0.0, 1.0, 0.0);
	else if (abs(hitPoint.z - minBound.z) < 0.001)
		hitFaceNormal = vec3(0.0, 0.0, -1.0);
	else if (abs(hitPoint.z - maxBound.z) < 0.001)
		hitFaceNormal = vec3(0.0, 0.0, 1.0);

	return true;
}

uint compact1By2(uint x) {
    x &= 0x09249249;
    x = (x ^ (x >> 2)) & 0x030c30c3;
    x = (x ^ (x >> 4)) & 0x0300f00f;
    x = (x ^ (x >> 8)) & 0x030000ff;
    x = (x ^ (x >> 16)) & 0x000003ff;
    return x;
}

uvec3 mortonToVec3(uint mortonCode) {
    return uvec3(
        compact1By2(mortonCode >> 0),
        compact1By2(mortonCode >> 1),
        compact1By2(mortonCode >> 2)
    );
}

void main() {
    vec4 color = vec4(0, 0, 0, 1.0);
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

	ivec2 viewportSize = imageSize(viewport);
	float aspectRatio = float(viewportSize.x) / float(viewportSize.y);

	vec3 worldUp = vec3(0, 1, 0);

	vec3 nCameraDirection = normalize(cameraDirection);
	vec3 cameraRight = normalize(cross(nCameraDirection, worldUp));
	vec3 cameraUp = normalize(cross(cameraRight, nCameraDirection));

	float fov = radians(cameraFov);
	float nearPlaneDist = tan(fov / 2) * 2;

	vec3 nearPlaneCenter = cameraPosition + (nCameraDirection * nearPlaneDist);
	vec3 rayOrigin = nearPlaneCenter
		+ cameraRight * (float(pixelCoord.x * 2 - viewportSize.x) / viewportSize.x) * aspectRatio
		- cameraUp * -(float(pixelCoord.y * 2 - viewportSize.y) / viewportSize.y);
	vec3 rayDirection = normalize(rayOrigin - cameraPosition);

	float voxelSize = 1;

	bool hit = false;
	vec3 hitFaceNormal;
	vec3 hitPoint;
	vec3 closestHitFaceNormal;
	float closestHitDistance = 1.0 / 0.0;

	for (uint i = 0; i < 3; i++) {

		if (int(voxelData[i]) == 0)
			continue;

		vec3 voxelPosition = mortonToVec3(i);

		if (rayIntersectsCube(rayOrigin, rayDirection, voxelPosition, voxelSize, hitPoint, hitFaceNormal)) {
			hit = true;
			float hitDistance = length(hitPoint - rayOrigin);
			if (hitDistance < closestHitDistance) {
				closestHitDistance = hitDistance;
				closestHitFaceNormal = hitFaceNormal;
			}
		}
	}

	if (hit) {
		color = vec4(1, 0, 0, 1);

		// lighting
		// https://math.hws.edu/graphicsbook/c7/s2.html

		vec4 lightColor = vec4(vec3(1), 1); // r g b intensity
		vec3 invLightDirection = normalize(vec3(-1, 1.5, 0.4));
		float specularIntensity = 0.3;
		float specularExponent = 5;

		float dotln = dot(invLightDirection, closestHitFaceNormal);
		if (dotln <= 0)
			color = vec4(vec3(0), 1);
		else {
			// diffusion
			color.rgb = (color * lightColor * dotln).rgb * lightColor.a;

			// specular
			vec3 lightReflectionDirection = reflect(invLightDirection * -1, closestHitFaceNormal);
			float i = dot(lightReflectionDirection, rayDirection * -1);
			if (i > 0)
				color.rgb += specularIntensity * pow(i, specularExponent) * lightColor.rgb;
		}
	}

	imageStore(viewport, pixelCoord, color);
}