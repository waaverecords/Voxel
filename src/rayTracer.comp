#version 460 core

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D viewport;

bool rayIntersectsCube(vec3 rayOrigin, vec3 rayDirection, vec3 cubePosition, float cubeSize) {
	vec3 invDir = 1.0 / rayDirection;
    vec3 tMin = (cubePosition - rayOrigin) * invDir;
    vec3 tMax = (cubePosition + vec3(cubeSize) - rayOrigin) * invDir;

    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);

    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    return tNear <= tFar && tFar >= 0.0;
}

void main() {
    vec4 color = vec4(0, 0, 0, 1.0);
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

	ivec2 viewportSize = imageSize(viewport);
	float aspectRatio = float(viewportSize.x) / float(viewportSize.y);

	vec3 up = vec3(0, 1, 0);

	vec3 cameraPosition = vec3(0, 0, 0);
	vec3 cameraDirection = vec3(0, 0, 1);
	vec3 cameraRight = normalize(cross(cameraDirection, up)); // TODO: check if normalize is needed
	vec3 cameraUp = normalize(cross(cameraRight, cameraDirection)); // TODO: check if normalize is needed

	float fov = radians(90);

	vec3 nearPlaneCenter = cameraPosition + (cameraDirection * tan(fov / 2));
	vec3 rayOrigin = nearPlaneCenter
		+ cameraRight * (-(float(pixelCoord.x * 2 - viewportSize.x) / viewportSize.x) * aspectRatio)
		- cameraUp * -(float(pixelCoord.y * 2 - viewportSize.y) / viewportSize.y);

	vec3 rayDirection = normalize(rayOrigin - cameraPosition);

	float cubeSize = 1;
	vec3 voxel1 = vec3(0, 0, 6);
	vec3 voxel2 = vec3(-0.5, -3, 4);
	vec3 voxel3 = vec3(-2, -1, 2);

	// z sorting would be necessary
	if (rayIntersectsCube(rayOrigin, rayDirection, voxel3, cubeSize))
		color.z = 1;
	else if (rayIntersectsCube(rayOrigin, rayDirection, voxel2, cubeSize))
		color.x = 1;
	else if (rayIntersectsCube(rayOrigin, rayDirection, voxel1, cubeSize))
		color.y = 1;

	imageStore(viewport, pixelCoord, color);
}